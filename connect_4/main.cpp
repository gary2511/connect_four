


// c4 console attempt.cpp : Defines the entry point for the console application.
//
// added to gitub and changed again and again

#include "stdafx.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <iostream>



/*#pragma config(Sensor, S1,     ,               sensorEV3_Color, modeEV3Color_Reflected_Raw)
//#pragma config(Sensor, S2,     ,               sensorEV3_Touch)
//#pragma config(Sensor, S3,     ,               sensorTouch)
//#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, PIDControl)
//#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, PIDControl)

//Code automatically generated by 'ROBOTC' configuration wizard   */





#define speed 35    // set the motor speed // 35 works 100%
#define red 1       // red pieces in the array are reperesented by a 1
#define yel 2       // yellow pieces in the array are reperesented by a 2
#define empty 0     // empty holes in the array are reperesented by a 0
#define start_wait 1000    // how long to stop at each row when scanning
#define place_piece_motor_tighten 60 // how many degrees to turn place piece motor to tighten it up to home
#define place_piece_motor_travel_distance 100 // how many degrees to move the place piece motor for full stroke 35?
#define down_speed 100
#define up_speed 75
#define horizontal_kick_distance 16 // horizontal jerk to the left to make sure chip drops


#define find_piece_reset_distance_back_to_row_seven 105 //////////////dump ????????????????????????????????????

/* constants for priority of next move */


#define none 0
#define random 1
#define lowest 2
#define low 3
#define medium 4
#define high 5
#define highest 6


const char *priority_text[] = { "none", "random" , "lowest", "low", "medium", "high", "Highest" };
const char *returned_by[] = { "error", "horizontal", "vertical", "rising left", "rising right", "random" };

bool got_input = false;

int move_count = 0;
int light_threshold = 0;   /* set auomticlly */


int find_player_move_spacing[8] = { 42,153,182,150,150,186,152,70 };  // find_player_move_spacing in degrees motor turn to each row 1015 =978
int x_array_total = 0;
int distance_between_rows = 0; // (the total of all the elements of the of the array  - find_piece_reset_distance_back_to_row_seven) / 6


int board[8][7];   // board is actually 7 by 6 but for ease of program readability I ignore the 0's

int moves_priority[3][50];
int moves_x[3][50];
int moves_y[3][50];
int moves_function_that_returnd_it[3][50];
int moves_if_ref[3][50];


bool computer_win = false;
bool player_win = false;
int computer_color;
int player_color;
char buf[1];
int pos = 0; // row number of robot

int total_numner_of_moves; // for debugging to test enter move to array is working

void home_x(void) //for robot
{
    // pos = 1;
}

void set_spacing(void)
{
    /*//////// distance back to row 7 is further than array [7] because row 7 is not in line with row 7 sensor
    int x;
    for (x = 0; x <= 7; x++)
    {
    x_array_total += find_player_move_spacing[x];
    }
    distance_between_rows = ((x_array_total - find_piece_reset_distance_back_to_row_seven) / 6); */
}

void enter_move_to_array(int color, int priority, int x, int y, int returned_by_function, int if_ref)
{
    bool done = false;
    for (int count = 0; count < 50; count++)
    {
        if (priority > moves_priority[color][count] && !done)
        {
            for (int loop = 49; loop > count; loop--)
            {
                moves_priority[color][loop] = moves_priority[color][loop - 1];
                moves_x[color][loop] = moves_x[color][loop - 1];
                moves_y[color][loop] = moves_y[color][loop - 1];
                moves_function_that_returnd_it[color][loop] = moves_function_that_returnd_it[color][loop - 1];
                moves_if_ref[color][loop] = moves_if_ref[color][loop - 1];
            }
            moves_priority[color][count] = priority;
            moves_x[color][count] = x;
            moves_y[color][count] = y;
            moves_function_that_returnd_it[color][count] = returned_by_function;
            moves_if_ref[color][count] = if_ref;
            done = true;
        }
    }
    total_numner_of_moves++;
}

bool player_won(int color)
{
    int win_count;
    int count;
    int four_count;
    int x;
    int y;

    bool won = false;

    // check for horizontal player win
    for (int y = 1; y <= 6; y++)
    {
        for (count = 1; count <= 4; count++)
        {
            win_count = 0;
            for (four_count = 0; four_count <= 3; four_count++)
            {
                if (board[count + four_count][y] == color)
                    win_count += 1;
            }
            if (win_count == 4)
                won = true;
        }
    }

    // check for vertical player win
    if (!won)
    {
        for (x = 1; x <= 7; x++)
        {
            for (count = 1; count <= 3; count++)
            {
                win_count = 0;
                for (four_count = 0; four_count <= 3; four_count++)
                {
                    if (board[x][count + four_count] == color)
                        win_count += 1;
                }
                if (win_count == 4)
                    won = true;
            }
        }
    }
    // check for diagonal player win rising left
    if (!won)
    {
        for (x = 4; x <= 7; x++)
        {
            for (y = 1; y <= 3; y++)
            {
                win_count = 0;
                if (board[x][y] == color)
                    win_count += 1;
                if (board[x - 1][y + 1] == color)
                    win_count += 1;
                if (board[x - 2][y + 2] == color)
                    win_count += 1;
                if (board[x - 3][y + 3] == color)
                    win_count += 1;
                if (win_count == 4)
                    won = true;
            }
        }
    }
    // check for diagonal player win rising right
    if (!won)
    {
        for (x = 1; x <= 4; x++)
        {
            for (y = 1; y <= 3; y++)
            {
                win_count = 0;
                if (board[x][y] == color)
                    win_count += 1;
                if (board[x + 1][y + 1] == color)
                    win_count += 1;
                if (board[x + 2][y + 2] == color)
                    win_count += 1;
                if (board[x + 3][y + 3] == color)
                    win_count += 1;
                if (win_count == 4)
                    won = true;
            }
        }
    }
    if (won)
        return(true);
    else
        return(false);
}

void draw_board(void)
{
    int x;
    int y;
    system("cls");
    printf("%s", "\n\n     1   2   3   4   5   6   7\n");
    printf("%s", "   -----------------------------\n");
    for (y = 6; y >= 1; y--)
    {
        if (y != 6)
            printf("%s", "   |---+---+---+---+---+---+---|\n");
        printf("%s", "   | ");
        for (x = 1; x <= 7; x++)
        {

            if (board[x][y] == 1)
                printf("%s", "X");

            if (board[x][y] == 2)
                printf("%s", "O");

            if (board[x][y] == 0)
                printf("%s", " ");

            printf("%s", " | ");
        }
        printf("\n");
    }
    printf("%s", "   -----------------------------\n");
}

void place_piece_motor_home(void)
{

}

void fake_thinking(void)  // this needs to just be passed x and colour and loop to work out y
{
    printf("%s", "\n\n");
    for (int loop_outer = 1; loop_outer < 6; loop_outer += 1)
    {
        printf("%s", "THINKING.....");
        for (int loop = 1; loop < 150000000; loop += 1) {}
    }
}

bool find_piece(int color)
{
    char user_input[1];
    int column = 0;
    bool ok = false;
    scanf("%c", user_input);
    column = atoi(user_input);
    if (column >= 1 && column <= 7)
    {
        for (int y = 1; y <= 6; y++)
        {
            if (!ok && board[column][y] == 0)
            {
                board[column][y] = color;
                ok = true;
            }
        }
    }
    pos = 7;
    return(ok);
}

void clear_board(void)
{
    for (int x = 1; x <= 7; x++)
    {
        for (int y = 1; y <= 6; y++)
        {
            board[x][y] = 0;
        }
    }
}

void check_for_horizontal_win_or_block(int color)
{
    for (int check_color = 1; check_color <= 2; check_color++)
    {
        for (int y = 1; y <= 6; y++)
        {
            for (int count = 1; count <= 7; count++)
            {
                //check for three together
                if (board[count][y] == check_color &&											// are there three of the same colour together together
                    board[count + 1][y] == check_color &&
                    board[count + 2][y] == check_color)
                {
                    if (count > 1 && board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1))
                    {
                        if (check_color == color)												// is the space before it available
                            enter_move_to_array(color, highest, count - 1, y, 1, 1);				// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count - 1, y, 1, 2);					// then place piece for for block
                    }
                    if (count < 5 && board[count + 3][y] == 0 && (board[count + 3][y - 1] != 0 || y == 1))
                    {
                        if (check_color == color)												// is the space after it avialable
                            enter_move_to_array(color, highest, count + 3, y, 1, 3);				// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count + 3, y, 1, 4);
                    }
                        // then place piece for for block
                }
                //check for splits i.e space COLOUR space colour space
                if (count > 1 && count < 5 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y] == check_color &&										// is there a space then another of the same color
                    (board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1)) &&	// is the space before it available
                    (board[count + 1][y] == 0 && (board[count + 1][y - 1] != 0 || y == 1)) &&	// is the space between the colors available
                    (board[count + 3][y] == 0 && (board[count + 3][y - 1] != 0 || y == 1)))		// is the space after it avialable
                    enter_move_to_array(color, high, count + 1, y, 1, 5);							// then place piece for for block or win next time

                // check for potential future splits
                // first COLOUR space colour unused_space
                if (count < 5 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y] == check_color &&										// is there a space then another of the same color
                    (board[count + 1][y] == 0 && (board[count + 1][y - 1] != 0 || y == 1)) &&	// is the space between the colors available
                    (board[count + 3][y] == 0 ))												// is the space after it empty
                    enter_move_to_array(color, medium, count + 1, y, 1, 6);						// then place piece for for block or win next time
                // first unused_space COLOUR space colour
                if (count > 1 && count < 6 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y] == check_color &&										// is there a space then another of the same color
                    (board[count + 1][y] == 0 && (board[count + 1][y - 1] != 0 || y == 1)) &&	// is the space between the colors available
                    (board[count - 1][y] == 0 ))												// is the space before it avialable
                    enter_move_to_array(color, medium, count + 1, y, 1, 7);						// then place piece for for block or win next time


                //check for two together
                if (board[count][y] == check_color &&											// are there two of the same colour together
                    board[count + 1][y] == check_color)
                {
                    // check for colour space COLOUR colour
                    if (count < 5 &&
                        board[count - 1][y] == 0 && board[count - 2][y] == check_color) 				// is the space before it empty and the one before that the same colour
                    {
                        if (board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1))		// is the space before it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count - 1, y, 1, 8);					// then place piece for win
                            else
                                enter_move_to_array(color, high, count - 1, y, 1, 9);						// then place piece for block
                        }
                    }
                    // check for COLOUR colour space colour
                    if (count < 5 &&
                        board[count + 2][y] == 0 && board[count + 3][y] == check_color) 				// is the second space after it empty and the one after that the same colour
                    {
                        if (board[count + 2][y] == 0 && (board[count + 2][y - 1] != 0 || y == 1))		// is the space after it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count + 2, y, 1, 10);					// then place piece for win
                            else
                                enter_move_to_array(color, high, count + 2, y, 1, 11);						// then place piece for block
                        }
                    }
                    // check for space COLOUR colour space
                    if (board[count - 1][y] == 0 && board[count + 2][y] == 0) 							// is the space before and after it empty
                    {
                        if ((count > 1 && count < 6 &&
                            board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1)) &&	// is the space before it available
                            (board[count + 2][y] == 0 && (board[count + 2][y - 1] != 0 || y == 1)))		// is the space after it avialable
                        {
                            enter_move_to_array(color, medium, count - 1, y, 1, 12);						// then place piece for move for block
                            enter_move_to_array(color, medium, count + 2, y, 1, 13);						// then place piece for move for block
                        }
                        else
                        {
                            if (count > 1 && count < 6 &&
                                board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1))	// is the space before it available
                                enter_move_to_array(color, low, count - 1, y, 1, 14);						// then place piece for move for block
                            if (count < 6 &&
                                board[count + 2][y] == 0 && (board[count + 2][y - 1] != 0 || y == 1))	// is the space after it available
                                enter_move_to_array(color, low, count + 2, y, 1, 15);						// then place piece for move for block
                        }
                    }
                    // check for space space COLOUR colour
                    if (count > 2 && count < 7 &&
                        (board[count - 1][y] == 0 && board[count - 2][y] == 0))							// are the two spaces before it empty
                    {
                        if (board[count - 1][y] == 0 && (board[count - 1][y - 1] != 0 || y == 1))		// is the space before it available
                            enter_move_to_array(color, lowest, count - 1, y, 1, 16);						// then place piece for move for block
                    }
                    // check for COLOUR colour space space
                    if (count < 5 && (board[count + 2][y] == 0 && board[count + 3][y] == 0))			// are the two spaces after it empty
                    {
                        if (board[count + 2][y] == 0 && (board[count + 2][y - 1] != 0 || y == 1))		// is the space after it available
                            enter_move_to_array(color, lowest, count + 2, y, 1, 17);						// then place piece for move for block
                    }
                }
            }
        }
    }
}

void check_for_vertical_win_or_block(int color)
{
    for (int x = 1; x <= 7; x++)
    {
        int red_count = 0;
        int yel_count = 0;
        for (int y = 1; y <= 6; y++)
        {
            int a = board[x][y];
            if (a != empty)
            {
                if (a == red)
                {
                    yel_count = 0;
                    red_count += 1;
                }
                if (a == yel)
                {
                    red_count = 0;
                    yel_count += 1;
                }
                if (red_count == 3 || yel_count == 3) // are there 3 the same?
                {
                    if (y <= 5 && board[x][y + 1] == 0) // is there a space to make a move feasible to win or block?
                    {
                        if (board[x][y] == color) // if computer color then place the piece for a win
                        {
                            if (color == computer_color)
                                enter_move_to_array(color, highest, x, y + 1, 2, 1);
                        }
                        else // else place the piece for the block
                        {
                            enter_move_to_array(color, high, x, y + 1, 2, 2);
                        }
                    }
                }
            }
        }
    }

}

void check_for_diagonal_win_or_block_rising_left(int color)
{
    for (int check_color = 1; check_color <= 2; check_color++)
    {
        for (int y = 1; y <= 6; y++)
        {
            for (int count = 1; count <= 7; count++)    //could it be 6 ????????
            {
                //check for three together colour colour COLOUR
                if (count > 2 && y < 5 &&
                    board[count][y] == check_color &&											// are there three of the same colour together together
                    board[count - 1][y + 1] == check_color &&
                    board[count - 2][y + 2] == check_color)
                {
                    if (count > 3 && y < 4 &&													// is the space before it available i.e. top left
                        board[count - 3][y + 3] == 0 && (board[count - 3][y + 2] != 0))
                    {
                        if (check_color == color)
                            enter_move_to_array(color, highest, count - 3, y + 3, 3, 1);			// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count - 3, y + 3, 3, 2);				// then place piece for block
                    }
                    if (count > 2 && count < 7 && y > 1 && 										// is the space after it avialable i.e. bottom right
                        board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0 || y - 1 == 1))
                    {
                        if (check_color == color)
                            enter_move_to_array(color, highest, count + 1, y - 1, 3, 3);			// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count + 1, y - 1, 3, 4);				// then place piece for for block
                    }
                }

                //check for splits i.e space colour space COLOUR space
                if (count > 3 && count < 7 && y > 1 && y < 4 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count - 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count - 3][y + 3] == 0 && (board[count - 3][y + 2] != 0)) &&			// is the space before it available i.e. top left
                    (board[count - 1][y + 1] == 0 && (board[count - 1][y] != 0)) &&				// is the space between the colors available
                    (board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0 || y - 1 == 1)))	// is the space after it avialable i.e. bottom right
                    enter_move_to_array(color, high, count - 1, y + 1, 3, 5);						// then place piece for for block or win next time

                // check for potential future splits
                // first unused_space colour space COLOUR
                if (count > 3 && y < 4 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count - 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count - 3][y + 3] == 0) &&											// is the space before it available i.e. top left
                    (board[count - 1][y + 1] == 0 && (board[count - 1][y] != 0)))				// is the space between the colors available
                    enter_move_to_array(color, medium, count - 1, y + 1, 3, 6);					// then place piece for block or move
                // second colour space COLOUR unused_space
                if (count > 2 && count < 7 && y > 1 && y < 5 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count - 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count - 1][y + 1] == 0 && (board[count - 1][y] != 0)) &&				// is the space between the colors available
                    (board[count + 1][y - 1] == 0))												// is the space after it avialable i.e. bottom right
                    enter_move_to_array(color, high, count - 1, y + 1, 3, 7);					// then place piece for for block or win next time

                //check for two together colour COLOUR
                if (count > 1 &&
                    board[count][y] == check_color &&											// are there two of the same colour together
                    board[count - 1][y + 1] == check_color)
                {
                    // check for colour space colour COLOUR
                    if (count > 3 && y < 4 &&													// is the second space before it empty and the one before that the same colour
                        board[count - 2][y + 2] == 0 && board[count - 3][y + 3] == check_color)
                    {
                        if (board[count - 2][y + 2] == 0 && (board[count - 2][y + 1] != 0))		// is the second space before it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count - 2, y + 2, 3, 8);		// then place piece for win
                            else
                                enter_move_to_array(color, high, count - 2, y + 2, 3, 9);			// then place piece for block
                        }
                    }
                    // check for colour COLOUR space colour
                    if (count > 1 && count < 6 && y > 2 && y < 6 &&
                        board[count + 1][y - 1] == 0 && board[count + 2][y - 2] == check_color) // is the space after it empty and the one after that the same colour
                    {
                        if (board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0))		// is the space after it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count + 1, y - 1, 3, 10);		// then place piece for win
                            else
                                enter_move_to_array(color, high, count + 1, y - 1, 3, 11);			// then place piece for block
                        }
                    }
                    // check for space colour COLOUR space
                    if (count > 2 && count < 7 && y > 1 && y < 5 &&
                        board[count - 2][y + 2] == 0 && board[count + 1][y - 1] == 0) 						// is the space before and after it empty
                    {
                        if ((board[count - 2][y + 2] == 0 && (board[count - 2][y + 1] != 0)) &&				// is the space before it available
                            (board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0 || y - 1 == 1)))		// is the space after it avialable
                        {
                            enter_move_to_array(color, medium, count - 2, y + 2, 3, 12);						// then place piece for block or move
                            enter_move_to_array(color, medium, count + 1, y - 1, 3, 13);						// then place piece for block or move
                        }
                        else
                        {
                            if (board[count - 2][y + 2] == 0 && (board[count - 2][y + 1] != 0))				// is the space before it available
                                enter_move_to_array(color, low, count - 2, y + 2, 3, 14);						// then place piece for block or move
                            if (board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0 || y - 1 == 1))	// is the space after it available
                                enter_move_to_array(color, low, count + 1, y - 1, 3, 15);						// then place piece for block or move
                        }
                    }
                    // check for space space colour COLOUR
                    if (count > 3 && y < 4 &&
                        (board[count - 2][y + 2] == 0 && board[count - 3][y + 3] == 0))						// are the two spaces before it empty
                    {
                        if (board[count - 2][y + 2] == 0 && (board[count - 2][y + 1] != 0))					// is the space before it available
                            enter_move_to_array(color, low, count - 2, y + 2, 3, 16);							// then place piece for block or move
                    }
                    // check for colour COLOUR space space
                    if (count > 1 && count < 6 && y > 2 && y < 6 &&
                        (board[count + 1][y - 1] == 0 && board[count + 2][y - 2] == 0))						// are the two spaces after it empty
                    {
                        if (board[count + 1][y - 1] == 0 && (board[count + 1][y - 2] != 0))					// is the space after it available
                            enter_move_to_array(color, lowest, count + 1, y - 1, 3, 17);						// then place piece for for block
                    }
                }
            }
        }
    }
}

void check_for_diagonal_win_or_block_rising_right(int color)
{
    for (int check_color = 1; check_color <= 2; check_color++)
    {
        for (int y = 1; y <= 6; y++)
        {
            for (int count = 1; count <= 7; count++)    //could it be 6 ????????
            {
                //check for three together COUNT count count
                if (count < 6 && y < 5 &&
                    board[count][y] == check_color &&											// are there three of the same colour together together
                    board[count + 1][y + 1] == check_color &&
                    board[count + 2][y + 2] == check_color)
                {
                    if (count < 5 && y < 4 &&													// is the space after it available i.e. top right
                        board[count + 3][y + 3] == 0 && (board[count + 3][y + 2] != 0))
                    {
                        if (check_color == color)
                            enter_move_to_array(color, highest, count + 3, y + 3, 4, 1);			// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count + 3, y + 3, 4, 2);				// then place piece for for block
                    }
                    if (count > 1 && count < 6 && y > 1 && y < 5 && 							// is the space brfore it avialable i.e. bottom left
                        board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0 || y - 1 == 1))
                    {
                        if (check_color == color)
                            enter_move_to_array(color, highest, count - 1, y - 1, 4, 3);			// if computer colour place piece for win
                        else
                            enter_move_to_array(color, high, count - 1, y - 1, 4, 4);				// then place piece for for block
                    }
                }
                //check for splits i.e space COLOUR space color space
                if (count > 1 && count < 5 && y > 1 && y < 4 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count + 3][y + 3] == 0 && (board[count + 3][y + 2] != 0)) &&			// is the space before it available i.e. top right
                    (board[count + 1][y + 1] == 0 && (board[count + 1][y] != 0)) &&				// is the space between the colors available
                    (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0 || y - 1 == 1)))	// is the space after it avialable i.e. bottom left
                    enter_move_to_array(color, high, count + 1, y + 1, 4, 5);						// then place piece for for block or win next time

                // check for potential future splits
                // first unused_space COLOUR space colour
                if (count > 1 && count < 6 && y > 1 && y < 5 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count + 1][y + 1] == 0 && (board[count + 1][y] != 0)) &&				// is the space between the colors available
                    (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0 || y - 1 == 1)))	// is the space before it avialable i.e. bottom left
                    enter_move_to_array(color, medium, count + 1, y + 1, 4, 6);					// then place piece for for block or move
                // second COLOUR space colour unused_space
                if (count < 4 && y < 4 &&
                    board[count][y] == check_color &&											// is there a color
                    board[count + 2][y + 2] == check_color &&									// is there a space then another of the same color
                    (board[count + 3][y + 3] == 0) &&											// is the space after it available i.e. top right
                    (board[count + 1][y + 1] == 0 && (board[count + 1][y] != 0)))				// is the space between the colors available
                    enter_move_to_array(color, medium, count + 1, y + 1, 4, 7);					// then place piece for for block or move


                //check for two together
                if (board[count][y] == check_color &&											// are there two of the same colour together
                    board[count + 1][y + 1] == check_color)
                {
                    // check for colour space COLOUR colour
                    if (count > 2 && count < 7 && y > 2 && y < 6 &&								// is the space before it empty and the one before that the same colour
                        board[count - 1][y - 1] == 0 && board[count - 2][y - 2] == check_color)
                    {
                        if (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0))		// is the space before it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count - 1, y - 1, 4, 8);		// then place piece for for win
                            else
                                enter_move_to_array(color, high, count - 1, y - 1, 4, 9);			// then place piece for for block
                        }
                    }
                    // check for COLOUR colour space colour
                    if (count < 5 && y < 4 &&
                        board[count + 2][y + 2] == 0 && board[count + 3][y + 3] == check_color) // is the space after it empty and the one after that the same colour
                    {
                        if (board[count + 2][y + 2] == 0 && (board[count + 2][y + 1] != 0))		// is the space after it available
                        {
                            if (check_color == color)
                                enter_move_to_array(color, highest, count + 2, y + 2, 4, 10);		// then place piece for for win
                            else
                                enter_move_to_array(color, high, count + 2, y + 2, 4, 11);			// then place piece for for block
                        }
                    }
                    // check for space COLOR colour space
                    if (count > 1 && count < 6 && y > 1 && y < 5 &&
                        board[count + 2][y + 2] == 0 && board[count - 1][y - 1] == 0) 					// is the space before and after it empty
                    {
                        if ((board[count + 2][y + 2] == 0 && (board[count + 2][y + 1] != 0)) &&			// is the space after it available
                            (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0 || y - 1 == 1)))	// is the space before it avialable
                        {
                            enter_move_to_array(color, medium, count + 2, y + 2, 4, 12);					// then place piece for for block or move
                            enter_move_to_array(color, medium, count - 1, y - 1, 4, 13);					// then place piece for for block or move
                        }
                        else
                        {
                            if (board[count + 2][y + 2] == 0 && (board[count + 2][y + 1] != 0))				// is the space after it available
                                enter_move_to_array(color, low, count + 2, y + 2, 4,14);						// then place piece for block or move
                            if (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0 || y - 1 == 1))	// is the space before it available
                                enter_move_to_array(color, low, count - 1, y - 1, 4, 15);						// then place piece for block or move
                        }
                    }
                    // check for space space COLOUR colour
                    if (count > 2 && count < 7 && y > 2 && y < 6 &&
                        (board[count - 1][y - 1] == 0 && board[count - 2][y - 2] == 0))			// are the two spaces before it empty
                    {
                        if (board[count - 1][y - 1] == 0 && (board[count - 1][y - 2] != 0))		// is the space before it available
                            enter_move_to_array(color, lowest, count - 1, y - 1, 4, 16);			// then place piece for block or move
                    }
                    // check for COLOUR colour space space
                    if (count < 5 && y < 4 &&
                        (board[count + 2][y + 2] == 0 && board[count + 3][y + 3] == 0))			// are the two spaces after it empty
                    {
                        if (board[count + 2][y + 2] == 0 && (board[count + 2][y + 1] != 0))		// is the space after it available
                            enter_move_to_array(color, lowest, count + 2, y + 2, 4, 17);			// then place piece for block or move
                    }
                }
            }
        }
    }
}

void populate_array_with_random_moves_in_case_no_move_found(void)
{
    bool placed;
    int num;
    int rows[] = { 0,0,0,0,0,0,0,0 };
    time_t t;
    srand((unsigned)time(&t)); // seed random number generator

    while (rows[1] + rows[2] + rows[3] + rows[4] + rows[5] + rows[6] + rows[7] != 7)
    {
        num = ( rand() % 7);
        if (num < 0) num = num*-1;
        num += 1;
        placed = false;
        if (rows[num] == 0)
        {
            rows[num] = 1;
            for (int y = 1; y <= 6; y++)
            {
                if (board[num][y] == 0 && !placed)
                {
                    enter_move_to_array(computer_color, random, num, y, 5, 1);
                    placed = true;
                }
            }
        }
    }
}

void check_moves(int color)
{
    check_for_horizontal_win_or_block(color);
    check_for_vertical_win_or_block(color);
    check_for_diagonal_win_or_block_rising_left(color);
    check_for_diagonal_win_or_block_rising_right(color);
}

int main()
{
    bool moved = false;
    int count = 0;
    int computer_row;
    bool debugging_on = false;

    //this is the setup test config
    bool set_up_test_array_in_play = false;

    set_spacing();
    clear_board();
    if (set_up_test_array_in_play)
    {
        /* blank board template to copy and paste

        { 0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0 },
        { 0,0,0,0,0,0,0 }
        */

        int test_board[6][7] = {
            { 0,0,0,0,0,0,0 },
            { 0,0,0,1,0,0,0 },
            { 0,0,0,1,1,1,0 },
            { 0,0,0,2,2,2,0 },
            { 0,0,0,2,2,2,0 },
            { 1,1,0,2,2,1,0 }
        }; //computer =1 "X" player =2 "0"
        for (int x = 1; x <= 8; x++)
        {
            for (int y = 1; y <= 7; y++)
            {
                board[x][y] = test_board[6 - y][x - 1];
            }
        }
    }
    // draw board and ask for move for first time only - after that board updates itself
    draw_board();
    printf("%s", "\n\nyour move, press row number then press enter  ");
    place_piece_motor_home(); //for testing moved to begininning of bn vnv

    computer_color = red;
    if (computer_color == red)
    {
        player_color = yel;
    }
    else
    {
        player_color = red;
    }

    while (!computer_win && !player_win)
    {
        moved = false;

        // clear the move arrays (only the field being tested)
        for (int count = 0; count < 50; count++)
        {
            moves_priority[computer_color][count] = 0;
            moves_priority[player_color][count] = 0;
        }
        total_numner_of_moves = 0; ///// for testing
        if (find_piece(player_color) && !computer_win && !player_win)
        {
            draw_board();
            if (player_won(player_color))
                player_win = true;

            check_moves(computer_color);
            populate_array_with_random_moves_in_case_no_move_found();
            for (count = 0; count < 50; count++)
            {

                if (moves_priority[computer_color][count] > none && !moved)
                {
                    board[moves_x[computer_color][count]][moves_y[computer_color][count]] = computer_color;
                    moved = true;
                    computer_row = moves_x[computer_color][count];
                }
                for (int count = 0; count < 50; count++) // clear array for player
                {
                    moves_priority[player_color][count] = 0;
                }

                check_moves(player_color);
                if (moves_priority[player_color][0] > none &&
                    moves_priority[computer_color][count] < highest &&
                    moves_priority[player_color][count] == highest &&
                    !computer_win)
                {
                    board[moves_x[computer_color][count]][moves_y[computer_color][count]] = none;
                    if (debugging_on)
                    {
                        printf("\for debugging computer undid move in row %d press any key to continue\n", moves_x[computer_color][count]);
                        getchar();
                        getchar();
                    }
                    moved = false;
                }
                else
                {
                    moved = true;
                }
            }
        }
        if (moved)
        {
            fake_thinking();
            draw_board();
            printf("%s", "\n\nyour move, press row number then press enter  ");
            printf("\n\ncomputer move was row  %d\n", computer_row);

            // next lines are for debugging - they print the valid moves from array
            if (debugging_on)
            {

                printf("\nplayer moves\n");
                for (int loop = 0; loop < 50; loop++)
                    if (moves_priority[player_color][loop] > none)
                        printf("HERE FOR DEBUGGING key %d priority = %s corrdinates are x=%d y=%d retuned by %s if ref %d\n", loop, priority_text[moves_priority[player_color][loop]], moves_x[player_color][loop], moves_y[player_color][loop], returned_by[moves_function_that_returnd_it[player_color][loop]], moves_if_ref[player_color][loop]);
                printf("\n\n");
                printf("\ncomputer moves total = %d\n", total_numner_of_moves);
                for (int loop = 0; loop < 50; loop++)
                    if (moves_priority[computer_color][loop])
                        printf("HERE FOR DEBUGGING key %d priority = %s corrdinates are x=%d y=%d retuned by %s if ref %d\n", loop, priority_text[moves_priority[computer_color][loop]], moves_x[computer_color][loop], moves_y[computer_color][loop], returned_by[moves_function_that_returnd_it[computer_color][loop]], moves_if_ref[computer_color][loop]);
            }
            // end of debugging info
        }
        if (player_won(computer_color))
            computer_win = true;
        move_count += 2;
        //home_x();
        //displayCenteredBigTextLine(4,"COMPUTER");
        //sprintf(buf, "%d", pos);
        //displayCenteredBigTextLine(7,buf);

        //		got_input == true;
    }
    if (computer_win)
        printf("%s", "\n\ncomputer won");
    if (player_win)
        printf("%s", "\n\nplayer won");
    getchar();
    getchar();
    getchar();
    getchar();
    getchar();
    getchar();
    getchar();
    //playSound(soundDownwardTones);
    return(true);
    // test
}
